# -*- coding: utf-8 -*-
"""
ë©”ì¸ íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ ëª¨ë“ˆ
"""
import logging
from datetime import datetime
import pandas as pd
from .data_manager import MultiCoinDataManager
from .portfolio_manager import MultiCoinPortfolioManager
from .social_sentiment import SocialSentimentBasedAlgorithm, TwitterSentimentCollector, RedditSentimentCollector

logger = logging.getLogger(__name__)

class MultiCoinTradingSystem:
    """ë‹¤ì¤‘ ì½”ì¸ í†µí•© íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ"""
    def __init__(self, initial_balance: float = 100000):
        logger.info(f"ğŸš€ íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ ì´ˆê¸°í™” - ì´ˆê¸° ìë³¸: ${initial_balance:,.2f}")
        self.config = TradingConfig()
        self.portfolio_manager = MultiCoinPortfolioManager()
        self.data_manager = MultiCoinDataManager()
        self.twitter_collector = TwitterSentimentCollector()
        self.reddit_collector = RedditSentimentCollector()
        self.algorithms = {}
        self.setup_algorithms()
        logger.info("âœ… íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ")

    def setup_algorithms(self):
        """ì•Œê³ ë¦¬ì¦˜ ì„¤ì •"""
        logger.info("ğŸ”§ ê±°ë˜ ì•Œê³ ë¦¬ì¦˜ ì„¤ì • ì¤‘...")
        social_algo = SocialSentimentBasedAlgorithm(self.twitter_collector, self.reddit_collector)
        self.algorithms['social_sentiment'] = {
            'algorithm': social_algo,
            'weight': 1.0,
            'enabled_coins': self.config.SUPPORTED_COINS[:6]
        }
        logger.info(f"âœ… {len(self.algorithms)}ê°œ ì•Œê³ ë¦¬ì¦˜ ì„¤ì • ì™„ë£Œ")

    def setup_portfolio_allocation(self, target_allocation: dict):
        """í¬íŠ¸í´ë¦¬ì˜¤ ëª©í‘œ ë°°ë¶„ ì„¤ì •"""
        self.portfolio_manager.set_target_allocation(target_allocation)
        logger.info("ğŸ¯ í¬íŠ¸í´ë¦¬ì˜¤ ëª©í‘œ ë°°ë¶„ ì„¤ì •:")
        for asset, weight in target_allocation.items():
            logger.info(f"  - {asset}: {weight:.1%}")

    def analyze_coin_signals(self, coin: str, data: pd.DataFrame) -> dict:
        """íŠ¹ì • ì½”ì¸ì— ëŒ€í•œ ì¢…í•© ì‹ í˜¸ ë¶„ì„"""
        # (ì‹ í˜¸ ë¶„ì„ ë¡œì§ êµ¬í˜„ë¶€)
        # ì—¬ê¸°ì„œëŠ” ê°„ë‹¨í•œ í™€ë“œ ì‹ í˜¸ë¡œ ëŒ€ì²´
        return {'decision': {'action': 'HOLD'}}

    def run_trading_cycle(self) -> dict:
        """í•œ ë²ˆì˜ ê±°ë˜ ì‚¬ì´í´ ì‹¤í–‰"""
        logger.info(f"ğŸ”„ ê±°ë˜ ì‚¬ì´í´ ì‹œì‘ - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        coins = self.config.SUPPORTED_COINS[:6]
        current_prices = self.data_manager.get_coin_prices(coins)
        
        active_signals = []
        for coin in coins:
            coin_data = self.data_manager.generate_multi_coin_data([coin], days=7)
            if not coin_data.empty:
                analysis = self.analyze_coin_signals(coin, coin_data[coin_data['coin'] == coin])
                if analysis['decision']['action'] != 'HOLD':
                    active_signals.append({'coin': coin, 'decision': analysis['decision']})

        if active_signals:
            logger.info(f"ğŸ“Š {len(active_signals)}ê°œì˜ í™œì„± ê±°ë˜ ì‹ í˜¸ ë°œê²¬.")
        else:
            logger.info("ğŸ“Š í™œì„± ê±°ë˜ ì‹ í˜¸ ì—†ìŒ.")
            
        portfolio_value = self.portfolio_manager.get_portfolio_value(current_prices)
        return {
            'timestamp': datetime.now(),
            'prices': current_prices,
            'active_signals': active_signals,
            'portfolio_value': portfolio_value
        }
    
    def perform_rebalancing(self, prices: dict):
        """í¬íŠ¸í´ë¦¬ì˜¤ ë¦¬ë°¸ëŸ°ì‹± ì‹¤í–‰"""
        logger.info("âš–ï¸ í¬íŠ¸í´ë¦¬ì˜¤ ë¦¬ë°¸ëŸ°ì‹± í™•ì¸ ì¤‘...")
        self.portfolio_manager.perform_rebalancing(prices)
